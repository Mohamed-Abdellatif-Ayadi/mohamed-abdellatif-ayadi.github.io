<div class="article-header"><img src="/images/sql-window-functions.svg" alt="Diagramme de fonctions de fenêtrage SQL" class="article-featured-image" /><p class="article-date">21 avril 2025</p></div><p>Les fonctions de fenêtrage SQL sont l'un des outils les plus puissants et flexibles disponibles pour les analystes et les développeurs. Elles permettent des calculs sophistiqués sur des lignes de données tout en préservant les lignes individuelles, ce qui les rend idéales pour une large gamme de cas d'utilisation, des classements et sommes cumulatives aux moyennes mobiles et comparaisons.</p><p>Ce billet de blog fournit une vue d'ensemble détaillée de toutes les principales fonctions de fenêtrage en utilisant la table Employees comme exemple.</p><div class="code-block"><pre><code>-- Créer la table
CREATE TABLE Employees (
    ID INT PRIMARY KEY,
    Name VARCHAR(100),
    DivisionID INT,
    ManagerID INT,
    Salary DECIMAL(10, 2)
);

-- Insérer des données dans la table Employees
INSERT INTO Employees (ID, Name, DivisionID, ManagerID, Salary)
VALUES
(356, 'Daniel Smith', 100, 133, 40000),
(122, 'Arnold Sully', 101, NULL, 60000),
(467, 'Lisa Roberts', 100, NULL, 80000),
(112, 'Mary Dial', 105, 467, 65000),
(775, 'Dennis Front', 103, NULL, 90000),
(111, 'Larry Weis', 104, 35534, 75000),
(222, 'Mark Red', 102, 133, 86000),
(577, 'Robert Night', 105, 12353, 76000),
(133, 'Susan Wall', 105, 577, 110000);</code></pre></div><h2 class="section-title">Que sont les fonctions de fenêtrage SQL?</h2><p>Les fonctions de fenêtrage SQL opèrent sur un ensemble de lignes, connu sous le nom de "fenêtre", défini par la clause OVER(). Contrairement aux fonctions d'agrégation comme SUM() ou COUNT(), les fonctions de fenêtrage renvoient un résultat pour chaque ligne du jeu de données, ce qui les rend incroyablement puissantes pour des analyses détaillées qui nécessitent à la fois des calculs au niveau des lignes individuelles et des opérations au niveau du groupe.</p><h2 class="section-title">Aperçu de la syntaxe</h2><p>La syntaxe générale d'une fonction de fenêtrage ressemble à ceci:</p><div class="code-block"><pre><code>&lt;window_function&gt;() OVER (
    [PARTITION BY column1, column2, ...]
    [ORDER BY column3, column4, ...]
)</code></pre></div><ul><li><strong>window_function</strong>: La fonction de fenêtrage (par exemple, ROW_NUMBER(), SUM(), RANK(), etc.).</li><li><strong>PARTITION BY</strong>: Divise le jeu de données en partitions (facultatif).</li><li><strong>ORDER BY</strong>: Spécifie l'ordonnancement des lignes dans chaque partition (facultatif).</li><li><strong>OVER()</strong>: Définit la fenêtre de lignes pour la fonction.</li></ul><h2 class="section-title">Fonctions de fenêtrage SQL clés</h2><div class="numbered-section"><div class="number-circle">1</div><h3>Fonctions de classement</h3></div><p>Les fonctions de classement sont utiles lorsque vous souhaitez attribuer un rang à chaque ligne dans une partition. Elles sont couramment utilisées dans des scénarios tels que la génération de tableaux de classement ou le classement des salaires des employés.</p><div class="highlight-box"><h4>ROW_NUMBER()</h4><p>Génère un numéro unique pour chaque ligne dans la partition. Exemple:</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    Salary,
    ROW_NUMBER() OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS SalaryRank
FROM Employees;</code></pre></div><p>Cette requête classe les employés dans chaque département par leur salaire en ordre décroissant.</p></div><div class="highlight-box"><h4>RANK()</h4><p>Attribue un rang à chaque ligne, mais laisse des lacunes en cas d'égalité. Le rang suivant est sauté pour les lignes ayant la même valeur. Exemple:</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    Salary,
    RANK() OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS SalaryRank
FROM Employees;</code></pre></div><p>Si deux employés ont le même salaire, ils auront le même rang, et le rang suivant sera sauté.</p></div><div class="highlight-box"><h4>DENSE_RANK()</h4><p>Similaire à RANK(), mais sans lacunes dans le classement. Toutes les lignes avec la même valeur reçoivent le même rang, mais les rangs suivants ne sont pas sautés. Exemple:</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    Salary,
    DENSE_RANK() OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS SalaryRank
FROM Employees;</code></pre></div></div><p>Les résultats de la requête sont les mêmes et seront:</p><div class="table-container"><table><thead><tr><th>DivisionID</th><th>Name</th><th>Salary</th><th>SalaryRank</th></tr></thead><tbody><tr><td>100</td><td>Lisa Roberts</td><td>80000.00</td><td>1</td></tr><tr><td>100</td><td>Daniel Smith</td><td>40000.00</td><td>2</td></tr><tr><td>101</td><td>Arnold Sully</td><td>60000.00</td><td>1</td></tr><tr><td>102</td><td>Mark Red</td><td>86000.00</td><td>1</td></tr><tr><td>103</td><td>Dennis Front</td><td>90000.00</td><td>1</td></tr><tr><td>104</td><td>Larry Weis</td><td>75000.00</td><td>1</td></tr><tr><td>105</td><td>Susan Wall</td><td>110000.00</td><td>1</td></tr><tr><td>105</td><td>Robert Night</td><td>76000.00</td><td>2</td></tr><tr><td>105</td><td>Mary Dial</td><td>65000.00</td><td>3</td></tr></tbody></table></div><div class="numbered-section"><div class="number-circle">2</div><h3>Fonctions d'agrégation (windowed)</h3></div><p>Les fonctions de fenêtrage peuvent être combinées avec des fonctions d'agrégation, vous permettant de calculer des valeurs comme des totaux cumulatifs ou des moyennes sans regrouper les lignes en un seul résultat.</p><div class="highlight-box"><h4>SUM()</h4><p>Calcule la somme cumulative sur une fenêtre de lignes. Exemple:</p><div class="code-block"><pre><code>SELECT employee_id, salary,
       SUM(salary) OVER (PARTITION BY department ORDER BY salary DESC) AS cumulative_salary
FROM employees;</code></pre></div><p>Cette requête calcule le salaire cumulatif pour chaque employé dans chaque département.</p></div><div class="table-container"><table><thead><tr><th>DivisionID</th><th>Name</th><th>Salary</th><th>CumulativeSalary</th></tr></thead><tbody><tr><td>100</td><td>Lisa Roberts</td><td>80000.00</td><td>80000.00</td></tr><tr><td>100</td><td>Daniel Smith</td><td>40000.00</td><td>120000.00</td></tr><tr><td>101</td><td>Arnold Sully</td><td>60000.00</td><td>60000.00</td></tr><tr><td>102</td><td>Mark Red</td><td>86000.00</td><td>86000.00</td></tr><tr><td>103</td><td>Dennis Front</td><td>90000.00</td><td>90000.00</td></tr><tr><td>104</td><td>Larry Weis</td><td>75000.00</td><td>75000.00</td></tr><tr><td>105</td><td>Susan Wall</td><td>110000.00</td><td>110000.00</td></tr><tr><td>105</td><td>Robert Night</td><td>76000.00</td><td>186000.00</td></tr><tr><td>105</td><td>Mary Dial</td><td>65000.00</td><td>251000.00</td></tr></tbody></table></div><div class="highlight-box"><h4>AVG()</h4><p>Calcule le salaire moyen des employés dans chaque département. Exemple:</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    Salary,
    AVG(Salary) OVER (PARTITION BY DivisionID) AS AvgSalary
FROM Employees;</code></pre></div></div><div class="table-container"><table><thead><tr><th>DivisionID</th><th>Name</th><th>Salary</th><th>AvgSalary</th></tr></thead><tbody><tr><td>100</td><td>Daniel Smith</td><td>40000.00</td><td>60000.000000</td></tr><tr><td>100</td><td>Lisa Roberts</td><td>80000.00</td><td>60000.000000</td></tr><tr><td>101</td><td>Arnold Sully</td><td>60000.00</td><td>60000.000000</td></tr><tr><td>102</td><td>Mark Red</td><td>86000.00</td><td>86000.000000</td></tr><tr><td>103</td><td>Dennis Front</td><td>90000.00</td><td>90000.000000</td></tr><tr><td>104</td><td>Larry Weis</td><td>75000.00</td><td>75000.000000</td></tr><tr><td>105</td><td>Mary Dial</td><td>65000.00</td><td>83666.666667</td></tr><tr><td>105</td><td>Susan Wall</td><td>110000.00</td><td>83666.666667</td></tr><tr><td>105</td><td>Robert Night</td><td>76000.00</td><td>83666.666667</td></tr></tbody></table></div><div class="highlight-box"><h4>COUNT()</h4><p>Compte le nombre de lignes dans la fenêtre. Exemple:</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    COUNT(*) OVER (PARTITION BY DivisionID) AS EmployeeCount
FROM Employees;</code></pre></div></div><div class="table-container"><table><thead><tr><th>DivisionID</th><th>Name</th><th>EmployeeCount</th></tr></thead><tbody><tr><td>100</td><td>Daniel Smith</td><td>2</td></tr><tr><td>100</td><td>Lisa Roberts</td><td>2</td></tr><tr><td>101</td><td>Arnold Sully</td><td>1</td></tr><tr><td>102</td><td>Mark Red</td><td>1</td></tr><tr><td>103</td><td>Dennis Front</td><td>1</td></tr><tr><td>104</td><td>Larry Weis</td><td>1</td></tr><tr><td>105</td><td>Mary Dial</td><td>3</td></tr><tr><td>105</td><td>Susan Wall</td><td>3</td></tr><tr><td>105</td><td>Robert Night</td><td>3</td></tr></tbody></table></div><div class="highlight-box"><h4>MAX() / MIN()</h4><p>Renvoie la valeur maximale ou minimale dans une fenêtre. Exemple: Trouver le salaire le plus élevé dans chaque département.</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    Salary,
    MAX(Salary) OVER (PARTITION BY DivisionID) AS MaxSalary
FROM Employees;</code></pre></div></div><div class="table-container"><table><thead><tr><th>DivisionID</th><th>Name</th><th>Salary</th><th>MaxSalary</th></tr></thead><tbody><tr><td>100</td><td>Daniel Smith</td><td>40000.00</td><td>80000.00</td></tr><tr><td>100</td><td>Lisa Roberts</td><td>80000.00</td><td>80000.00</td></tr><tr><td>101</td><td>Arnold Sully</td><td>60000.00</td><td>60000.00</td></tr><tr><td>102</td><td>Mark Red</td><td>86000.00</td><td>86000.00</td></tr><tr><td>103</td><td>Dennis Front</td><td>90000.00</td><td>90000.00</td></tr><tr><td>104</td><td>Larry Weis</td><td>75000.00</td><td>75000.00</td></tr><tr><td>105</td><td>Mary Dial</td><td>65000.00</td><td>110000.00</td></tr><tr><td>105</td><td>Susan Wall</td><td>110000.00</td><td>110000.00</td></tr><tr><td>105</td><td>Robert Night</td><td>76000.00</td><td>110000.00</td></tr></tbody></table></div><div class="numbered-section"><div class="number-circle">3</div><h3>Fonctions analytiques</h3></div><p>Les fonctions analytiques sont utilisées pour des calculs plus complexes tels que la détermination de la position d'une valeur dans un ensemble, l'exécution de calculs basés sur des positions relatives, ou l'accès à des valeurs d'autres lignes.</p><div class="highlight-box"><h4>NTILE()</h4><p>Divise les lignes en un nombre spécifié de groupes approximativement égaux et attribue un numéro de bucket à chaque ligne. Exemple:</p><div class="code-block"><pre><code>SELECT
    Name,
    Salary,
    NTILE(3) OVER (ORDER BY Salary DESC) AS SalaryTertile
FROM Employees;</code></pre></div><p>Cette requête divise les employés en trois tertiles de salaire.</p></div><div class="highlight-box"><h4>LEAD() / LAG()</h4><p>Accède aux données d'une ligne suivante (LEAD) ou précédente (LAG) dans l'ensemble de résultats. Exemple:</p><div class="code-block"><pre><code>SELECT
    Name,
    Salary,
    LAG(Salary) OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS PreviousSalary,
    LEAD(Salary) OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS NextSalary
FROM Employees;</code></pre></div><p>Cette requête affiche le salaire de chaque employé ainsi que le salaire suivant et précédent dans le même département.</p></div><div class="highlight-box"><h4>FIRST_VALUE() / LAST_VALUE()</h4><p>Renvoie la première ou la dernière valeur dans un cadre de fenêtre ordonné. Exemple:</p><div class="code-block"><pre><code>SELECT
    Name,
    DivisionID,
    Salary,
    FIRST_VALUE(Name) OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS HighestPaidInDept
FROM Employees;</code></pre></div><p>Cette requête affiche le nom de l'employé le mieux payé dans chaque département à côté des détails de chaque employé.</p></div><div class="table-container"><table><thead><tr><th>Name</th><th>DivisionID</th><th>Salary</th><th>HighestPaidInDept</th></tr></thead><tbody><tr><td>Lisa Roberts</td><td>100</td><td>80000.00</td><td>Lisa Roberts</td></tr><tr><td>Daniel Smith</td><td>100</td><td>40000.00</td><td>Lisa Roberts</td></tr><tr><td>Arnold Sully</td><td>101</td><td>60000.00</td><td>Arnold Sully</td></tr><tr><td>Mark Red</td><td>102</td><td>86000.00</td><td>Mark Red</td></tr><tr><td>Dennis Front</td><td>103</td><td>90000.00</td><td>Dennis Front</td></tr><tr><td>Larry Weis</td><td>104</td><td>75000.00</td><td>Larry Weis</td></tr><tr><td>Susan Wall</td><td>105</td><td>110000.00</td><td>Susan Wall</td></tr><tr><td>Robert Night</td><td>105</td><td>76000.00</td><td>Susan Wall</td></tr><tr><td>Mary Dial</td><td>105</td><td>65000.00</td><td>Susan Wall</td></tr></tbody></table></div><h2 class="section-title">Applications pratiques</h2><p>Les fonctions de fenêtrage SQL ont d'innombrables applications pratiques. Voici quelques cas d'utilisation courants:</p><ol><li><strong>Calcul des taux de croissance mois par mois</strong> pour les métriques commerciales</li><li><strong>Identification des anomalies</strong> en comparant les valeurs aux moyennes mobiles</li><li><strong>Création de tableaux de classement</strong> ou de classements au sein des catégories</li><li><strong>Analyse du comportement des utilisateurs</strong> dans le temps avec une analyse séquentielle</li><li><strong>Construction d'analyses de cohortes</strong> pour les segments de clients</li></ol><h2 class="section-title">Considérations de performance</h2><p>Bien que les fonctions de fenêtrage soient puissantes, elles peuvent être coûteuses en termes de calcul. Voici quelques conseils pour optimiser les performances:</p><ol><li><strong>Utilisez une indexation appropriée</strong> pour les colonnes dans les clauses PARTITION BY et ORDER BY</li><li><strong>Limitez l'ensemble de résultats</strong> avant d'appliquer des fonctions de fenêtrage lorsque c'est possible</li><li><strong>Utilisez des clauses de cadre de fenêtre</strong> (ROWS BETWEEN) pour restreindre la taille de la fenêtre pour de meilleures performances</li><li><strong>Envisagez la matérialisation des résultats intermédiaires</strong> dans des requêtes complexes avec plusieurs fonctions de fenêtrage</li></ol><h2 class="section-title">Conclusion</h2><p>Les fonctions de fenêtrage SQL sont un outil indispensable pour l'analyse avancée des données. En maîtrisant ces fonctions, vous pouvez écrire des requêtes plus élégantes et efficaces qui fournissent des aperçus plus profonds de vos données.</p><p>La prochaine fois que vous vous trouvez à écrire des sous-requêtes complexes ou à utiliser des auto-jointures pour résoudre des problèmes analytiques, considérez si une fonction de fenêtrage pourrait offrir une solution plus simple et plus performante.</p>