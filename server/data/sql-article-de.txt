<div class="article-header"><img src="/images/sql-window-functions.svg" alt="SQL-Fensterfunktionen Diagramm" class="article-featured-image" /><p class="article-date">21. April 2025</p></div><p>SQL-Fensterfunktionen gehören zu den leistungsstärksten und flexibelsten Werkzeugen für Analysten und Entwickler. Sie ermöglichen anspruchsvolle Berechnungen über Datenzeilen hinweg, während die einzelnen Zeilen erhalten bleiben, was sie ideal für eine Vielzahl von Anwendungsfällen macht, von Rangfolgen und kumulativen Summen bis hin zu gleitenden Durchschnitten und Vergleichen.</p><p>Dieser Blogbeitrag bietet einen detaillierten Überblick über alle wichtigen Fensterfunktionen anhand der Tabelle "Employees" als Beispiel.</p><div class="code-block"><pre><code>-- Tabelle erstellen
CREATE TABLE Employees (
    ID INT PRIMARY KEY,
    Name VARCHAR(100),
    DivisionID INT,
    ManagerID INT,
    Salary DECIMAL(10, 2)
);

-- Daten in die Employees-Tabelle einfügen
INSERT INTO Employees (ID, Name, DivisionID, ManagerID, Salary)
VALUES
(356, 'Daniel Smith', 100, 133, 40000),
(122, 'Arnold Sully', 101, NULL, 60000),
(467, 'Lisa Roberts', 100, NULL, 80000),
(112, 'Mary Dial', 105, 467, 65000),
(775, 'Dennis Front', 103, NULL, 90000),
(111, 'Larry Weis', 104, 35534, 75000),
(222, 'Mark Red', 102, 133, 86000),
(577, 'Robert Night', 105, 12353, 76000),
(133, 'Susan Wall', 105, 577, 110000);</code></pre></div><h2 class="section-title">Was sind SQL-Fensterfunktionen?</h2><p>SQL-Fensterfunktionen arbeiten mit einer Gruppe von Zeilen, bekannt als "Fenster", die durch die OVER()-Klausel definiert wird. Im Gegensatz zu Aggregatfunktionen wie SUM() oder COUNT() geben Fensterfunktionen für jede Zeile im Datensatz ein Ergebnis zurück, was sie unglaublich leistungsstark für detaillierte Analysen macht, die sowohl Berechnungen auf Zeilenebene als auch auf Gruppenebene erfordern.</p><h2 class="section-title">Syntax-Überblick</h2><p>Die allgemeine Syntax einer Fensterfunktion sieht wie folgt aus:</p><div class="code-block"><pre><code>&lt;window_function&gt;() OVER (
    [PARTITION BY column1, column2, ...]
    [ORDER BY column3, column4, ...]
)</code></pre></div><ul><li><strong>window_function</strong>: Die Fensterfunktion (z.B. ROW_NUMBER(), SUM(), RANK(), etc.).</li><li><strong>PARTITION BY</strong>: Teilt den Datensatz in Partitionen (optional).</li><li><strong>ORDER BY</strong>: Spezifiziert die Reihenfolge der Zeilen innerhalb jeder Partition (optional).</li><li><strong>OVER()</strong>: Definiert das Fenster der Zeilen für die Funktion.</li></ul><h2 class="section-title">Wichtige SQL-Fensterfunktionen</h2><div class="numbered-section"><div class="number-circle">1</div><h3>Ranking-Funktionen</h3></div><p>Ranking-Funktionen sind nützlich, wenn Sie jeder Zeile innerhalb einer Partition einen Rang zuweisen möchten. Sie werden häufig in Szenarien wie der Generierung von Ranglisten oder der Gehaltsrangfolge von Mitarbeitern verwendet.</p><div class="highlight-box"><h4>ROW_NUMBER()</h4><p>Generiert eine eindeutige Nummer für jede Zeile in der Partition. Beispiel:</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    Salary,
    ROW_NUMBER() OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS SalaryRank
FROM Employees;</code></pre></div><p>Diese Abfrage ordnet die Mitarbeiter in jeder Abteilung nach ihrem Gehalt in absteigender Reihenfolge.</p></div><div class="highlight-box"><h4>RANK()</h4><p>Weist jeder Zeile einen Rang zu, lässt aber Lücken, wenn es Bindungen gibt. Der nächste Rang wird für Zeilen mit dem gleichen Wert übersprungen. Beispiel:</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    Salary,
    RANK() OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS SalaryRank
FROM Employees;</code></pre></div><p>Wenn zwei Mitarbeiter dasselbe Gehalt haben, erhalten sie denselben Rang, und der nächste Rang wird übersprungen.</p></div><div class="highlight-box"><h4>DENSE_RANK()</h4><p>Ähnlich wie RANK(), aber ohne Lücken im Ranking. Alle Zeilen mit dem gleichen Wert erhalten den gleichen Rang, aber nachfolgende Ränge werden nicht übersprungen. Beispiel:</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    Salary,
    DENSE_RANK() OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS SalaryRank
FROM Employees;</code></pre></div></div><p>Die Abfrageergebnisse sind gleich und werden sein:</p><div class="table-container"><table><thead><tr><th>DivisionID</th><th>Name</th><th>Salary</th><th>SalaryRank</th></tr></thead><tbody><tr><td>100</td><td>Lisa Roberts</td><td>80000.00</td><td>1</td></tr><tr><td>100</td><td>Daniel Smith</td><td>40000.00</td><td>2</td></tr><tr><td>101</td><td>Arnold Sully</td><td>60000.00</td><td>1</td></tr><tr><td>102</td><td>Mark Red</td><td>86000.00</td><td>1</td></tr><tr><td>103</td><td>Dennis Front</td><td>90000.00</td><td>1</td></tr><tr><td>104</td><td>Larry Weis</td><td>75000.00</td><td>1</td></tr><tr><td>105</td><td>Susan Wall</td><td>110000.00</td><td>1</td></tr><tr><td>105</td><td>Robert Night</td><td>76000.00</td><td>2</td></tr><tr><td>105</td><td>Mary Dial</td><td>65000.00</td><td>3</td></tr></tbody></table></div><div class="numbered-section"><div class="number-circle">2</div><h3>Aggregatfunktionen (windowed)</h3></div><p>Fensterfunktionen können mit Aggregatfunktionen kombiniert werden, so dass Sie Werte wie laufende Summen oder Durchschnittswerte berechnen können, ohne die Zeilen zu einem einzigen Ergebnis zusammenzufassen.</p><div class="highlight-box"><h4>SUM()</h4><p>Berechnet die kumulative Summe über ein Fenster von Zeilen. Beispiel:</p><div class="code-block"><pre><code>SELECT employee_id, salary,
       SUM(salary) OVER (PARTITION BY department ORDER BY salary DESC) AS cumulative_salary
FROM employees;</code></pre></div><p>Diese Abfrage berechnet das kumulative Gehalt für jeden Mitarbeiter in jeder Abteilung.</p></div><div class="table-container"><table><thead><tr><th>DivisionID</th><th>Name</th><th>Salary</th><th>CumulativeSalary</th></tr></thead><tbody><tr><td>100</td><td>Lisa Roberts</td><td>80000.00</td><td>80000.00</td></tr><tr><td>100</td><td>Daniel Smith</td><td>40000.00</td><td>120000.00</td></tr><tr><td>101</td><td>Arnold Sully</td><td>60000.00</td><td>60000.00</td></tr><tr><td>102</td><td>Mark Red</td><td>86000.00</td><td>86000.00</td></tr><tr><td>103</td><td>Dennis Front</td><td>90000.00</td><td>90000.00</td></tr><tr><td>104</td><td>Larry Weis</td><td>75000.00</td><td>75000.00</td></tr><tr><td>105</td><td>Susan Wall</td><td>110000.00</td><td>110000.00</td></tr><tr><td>105</td><td>Robert Night</td><td>76000.00</td><td>186000.00</td></tr><tr><td>105</td><td>Mary Dial</td><td>65000.00</td><td>251000.00</td></tr></tbody></table></div><div class="highlight-box"><h4>AVG()</h4><p>Berechnet das durchschnittliche Gehalt für Mitarbeiter in jeder Abteilung. Beispiel:</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    Salary,
    AVG(Salary) OVER (PARTITION BY DivisionID) AS AvgSalary
FROM Employees;</code></pre></div></div><div class="table-container"><table><thead><tr><th>DivisionID</th><th>Name</th><th>Salary</th><th>AvgSalary</th></tr></thead><tbody><tr><td>100</td><td>Daniel Smith</td><td>40000.00</td><td>60000.000000</td></tr><tr><td>100</td><td>Lisa Roberts</td><td>80000.00</td><td>60000.000000</td></tr><tr><td>101</td><td>Arnold Sully</td><td>60000.00</td><td>60000.000000</td></tr><tr><td>102</td><td>Mark Red</td><td>86000.00</td><td>86000.000000</td></tr><tr><td>103</td><td>Dennis Front</td><td>90000.00</td><td>90000.000000</td></tr><tr><td>104</td><td>Larry Weis</td><td>75000.00</td><td>75000.000000</td></tr><tr><td>105</td><td>Mary Dial</td><td>65000.00</td><td>83666.666667</td></tr><tr><td>105</td><td>Susan Wall</td><td>110000.00</td><td>83666.666667</td></tr><tr><td>105</td><td>Robert Night</td><td>76000.00</td><td>83666.666667</td></tr></tbody></table></div><div class="highlight-box"><h4>COUNT()</h4><p>Zählt die Anzahl der Zeilen im Fenster. Beispiel:</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    COUNT(*) OVER (PARTITION BY DivisionID) AS EmployeeCount
FROM Employees;</code></pre></div></div><div class="table-container"><table><thead><tr><th>DivisionID</th><th>Name</th><th>EmployeeCount</th></tr></thead><tbody><tr><td>100</td><td>Daniel Smith</td><td>2</td></tr><tr><td>100</td><td>Lisa Roberts</td><td>2</td></tr><tr><td>101</td><td>Arnold Sully</td><td>1</td></tr><tr><td>102</td><td>Mark Red</td><td>1</td></tr><tr><td>103</td><td>Dennis Front</td><td>1</td></tr><tr><td>104</td><td>Larry Weis</td><td>1</td></tr><tr><td>105</td><td>Mary Dial</td><td>3</td></tr><tr><td>105</td><td>Susan Wall</td><td>3</td></tr><tr><td>105</td><td>Robert Night</td><td>3</td></tr></tbody></table></div><div class="highlight-box"><h4>MAX() / MIN()</h4><p>Gibt den maximalen oder minimalen Wert in einem Fenster zurück. Beispiel: Finden Sie das höchste Gehalt in jeder Abteilung.</p><div class="code-block"><pre><code>SELECT
    DivisionID,
    Name,
    Salary,
    MAX(Salary) OVER (PARTITION BY DivisionID) AS MaxSalary
FROM Employees;</code></pre></div></div><div class="table-container"><table><thead><tr><th>DivisionID</th><th>Name</th><th>Salary</th><th>MaxSalary</th></tr></thead><tbody><tr><td>100</td><td>Daniel Smith</td><td>40000.00</td><td>80000.00</td></tr><tr><td>100</td><td>Lisa Roberts</td><td>80000.00</td><td>80000.00</td></tr><tr><td>101</td><td>Arnold Sully</td><td>60000.00</td><td>60000.00</td></tr><tr><td>102</td><td>Mark Red</td><td>86000.00</td><td>86000.00</td></tr><tr><td>103</td><td>Dennis Front</td><td>90000.00</td><td>90000.00</td></tr><tr><td>104</td><td>Larry Weis</td><td>75000.00</td><td>75000.00</td></tr><tr><td>105</td><td>Mary Dial</td><td>65000.00</td><td>110000.00</td></tr><tr><td>105</td><td>Susan Wall</td><td>110000.00</td><td>110000.00</td></tr><tr><td>105</td><td>Robert Night</td><td>76000.00</td><td>110000.00</td></tr></tbody></table></div><div class="numbered-section"><div class="number-circle">3</div><h3>Analytische Funktionen</h3></div><p>Analytische Funktionen werden für komplexere Berechnungen verwendet, wie die Bestimmung der Position eines Wertes innerhalb einer Menge, die Durchführung von Berechnungen basierend auf relativen Positionen oder den Zugriff auf Werte aus anderen Zeilen.</p><div class="highlight-box"><h4>NTILE()</h4><p>Teilt die Zeilen in eine angegebene Anzahl von ungefähr gleichen Gruppen und weist jeder Zeile eine Bucket-Nummer zu. Beispiel:</p><div class="code-block"><pre><code>SELECT
    Name,
    Salary,
    NTILE(3) OVER (ORDER BY Salary DESC) AS SalaryTertile
FROM Employees;</code></pre></div><p>Diese Abfrage teilt die Mitarbeiter in drei Gehaltsterzile ein.</p></div><div class="highlight-box"><h4>LEAD() / LAG()</h4><p>Greift auf Daten aus einer nachfolgenden (LEAD) oder vorherigen (LAG) Zeile im Ergebnissatz zu. Beispiel:</p><div class="code-block"><pre><code>SELECT
    Name,
    Salary,
    LAG(Salary) OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS PreviousSalary,
    LEAD(Salary) OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS NextSalary
FROM Employees;</code></pre></div><p>Diese Abfrage zeigt das Gehalt jedes Mitarbeiters zusammen mit dem nächsten und vorherigen Gehalt in derselben Abteilung.</p></div><div class="highlight-box"><h4>FIRST_VALUE() / LAST_VALUE()</h4><p>Gibt den ersten oder letzten Wert in einem geordneten Fensterrahmen zurück. Beispiel:</p><div class="code-block"><pre><code>SELECT
    Name,
    DivisionID,
    Salary,
    FIRST_VALUE(Name) OVER (PARTITION BY DivisionID ORDER BY Salary DESC) AS HighestPaidInDept
FROM Employees;</code></pre></div><p>Diese Abfrage zeigt den Namen des bestbezahlten Mitarbeiters in jeder Abteilung neben den Details jedes Mitarbeiters.</p></div><div class="table-container"><table><thead><tr><th>Name</th><th>DivisionID</th><th>Salary</th><th>HighestPaidInDept</th></tr></thead><tbody><tr><td>Lisa Roberts</td><td>100</td><td>80000.00</td><td>Lisa Roberts</td></tr><tr><td>Daniel Smith</td><td>100</td><td>40000.00</td><td>Lisa Roberts</td></tr><tr><td>Arnold Sully</td><td>101</td><td>60000.00</td><td>Arnold Sully</td></tr><tr><td>Mark Red</td><td>102</td><td>86000.00</td><td>Mark Red</td></tr><tr><td>Dennis Front</td><td>103</td><td>90000.00</td><td>Dennis Front</td></tr><tr><td>Larry Weis</td><td>104</td><td>75000.00</td><td>Larry Weis</td></tr><tr><td>Susan Wall</td><td>105</td><td>110000.00</td><td>Susan Wall</td></tr><tr><td>Robert Night</td><td>105</td><td>76000.00</td><td>Susan Wall</td></tr><tr><td>Mary Dial</td><td>105</td><td>65000.00</td><td>Susan Wall</td></tr></tbody></table></div><h2 class="section-title">Praktische Anwendungen</h2><p>SQL-Fensterfunktionen haben unzählige praktische Anwendungen. Hier sind einige häufige Anwendungsfälle:</p><ol><li><strong>Berechnung von Wachstumsraten von Monat zu Monat</strong> für Geschäftsmetriken</li><li><strong>Identifizierung von Anomalien</strong> durch Vergleich von Werten mit gleitenden Durchschnitten</li><li><strong>Erstellung von Ranglisten</strong> oder Rankings innerhalb von Kategorien</li><li><strong>Analyse des Benutzerverhaltens</strong> im Zeitverlauf mit sequentieller Analyse</li><li><strong>Erstellung von Kohortenanalysen</strong> für Kundensegmente</li></ol><h2 class="section-title">Leistungsüberlegungen</h2><p>Obwohl Fensterfunktionen leistungsstark sind, können sie rechenintensiv sein. Hier sind einige Tipps zur Optimierung der Leistung:</p><ol><li><strong>Verwenden Sie geeignete Indizierung</strong> für Spalten in PARTITION BY- und ORDER BY-Klauseln</li><li><strong>Begrenzen Sie das Ergebnisset</strong> vor der Anwendung von Fensterfunktionen, wenn möglich</li><li><strong>Verwenden Sie Fensterrahmenklauseln</strong> (ROWS BETWEEN), um die Fenstergröße für bessere Leistung zu beschränken</li><li><strong>Erwägen Sie die Materialisierung von Zwischenergebnissen</strong> in komplexen Abfragen mit mehreren Fensterfunktionen</li></ol><h2 class="section-title">Fazit</h2><p>SQL-Fensterfunktionen sind ein unverzichtbares Werkzeug für fortgeschrittene Datenanalysen. Durch die Beherrschung dieser Funktionen können Sie elegantere und effizientere Abfragen schreiben, die tiefere Einblicke in Ihre Daten bieten.</p><p>Wenn Sie das nächste Mal komplexe Unterabfragen oder Self-Joins schreiben, um analytische Probleme zu lösen, überlegen Sie, ob eine Fensterfunktion eine klarere und leistungsfähigere Lösung bieten könnte.</p>